from django.db import models
from django.conf import settings
from django.contrib.auth.models import AbstractUser
from django.db.models.signals import post_save
from django.dispatch import receiver

# ---------------- Custom User ----------------
class CustomUser(AbstractUser):
    avatar = models.ImageField(upload_to="avatars/", blank=True, null=True)
    preferences = models.TextField(blank=True, null=True)
    email = models.EmailField(unique=True)  

    def __str__(self):
        return self.username

# ---------------- Profile ----------------
class Profile(models.Model):
    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE)
    display_name = models.CharField(max_length=50, blank=True)
    avatar = models.ImageField(upload_to='avatars/', blank=True, null=True)
    preferences = models.TextField(blank=True)

    def __str__(self):
        return self.user.username

class BaseModel(models.Model):
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        abstract = True

class Category(BaseModel):
    name = models.CharField(max_length=100, unique=True)
    description = models.TextField(blank=True)

    def __str__(self):
        return self.name

class SubCategory(BaseModel):
    name = models.CharField(max_length=100)
    category = models.ForeignKey(Category, related_name='subcategories', on_delete=models.CASCADE)

    class Meta:
        unique_together = ['name', 'category']

    def __str__(self):
        return f"{self.category.name} - {self.name}"

class Quiz(BaseModel):
    DIFFICULTY_CHOICES = [
        ('E', 'Easy'),
        ('M', 'Medium'),
        ('H', 'Hard'),
    ]
    
    title = models.CharField(max_length=255)
    description = models.TextField(blank=True)
    category = models.ForeignKey(Category, related_name='quizzes', on_delete=models.CASCADE)
    subcategory = models.ForeignKey(SubCategory, related_name='quizzes', on_delete=models.CASCADE, null=True, blank=True)
    difficulty = models.CharField(max_length=1, choices=DIFFICULTY_CHOICES, default='M')
    time_limit_minutes = models.PositiveIntegerField(default=30, help_text="Time limit in minutes")
    is_ai_generated = models.BooleanField(default=False, help_text="Whether this quiz was generated by AI")

    def clean(self):
        from django.core.exceptions import ValidationError
        if self.subcategory and self.subcategory.category != self.category:
            raise ValidationError("Subcategory must belong to the selected category")

    def save(self, *args, **kwargs):
        self.full_clean()
        super().save(*args, **kwargs)

    def __str__(self):
        return f"{self.title} ({self.get_difficulty_display()})"

class Question(BaseModel):
    DIFFICULTY_CHOICES = [
        ('E', 'Easy'),
        ('M', 'Medium'),
        ('H', 'Hard'),
    ]
    
    ANSWER_CHOICES = [
        ("A", "Option A"),
        ("B", "Option B"),
        ("C", "Option C"),
        ("D", "Option D"),
    ]

    quiz = models.ForeignKey(Quiz, related_name='questions', on_delete=models.CASCADE)
    text = models.TextField()
    difficulty = models.CharField(max_length=1, choices=DIFFICULTY_CHOICES, default='M')
    is_ai_generated = models.BooleanField(default=False, help_text="Whether this question was generated by AI")

    option1 = models.CharField(max_length=255)
    option2 = models.CharField(max_length=255)
    option3 = models.CharField(max_length=255)
    option4 = models.CharField(max_length=255)

    correct_answer = models.CharField(choices=ANSWER_CHOICES, max_length=1)

    def get_correct_option(self):
        """Return the correct option text"""
        option_mapping = {
            'A': self.option1,
            'B': self.option2,
            'C': self.option3,
            'D': self.option4
        }
        return option_mapping.get(self.correct_answer, '')

    def get_options_dict(self):
        """Return options as a dictionary"""
        return {
            'A': self.option1,
            'B': self.option2,
            'C': self.option3,
            'D': self.option4
        }

    def __str__(self):
        return f"{self.text[:50]}... ({self.get_difficulty_display()})"

class QuizHistory(BaseModel):
    # Use string reference to avoid circular dependency
    user = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='quiz_histories')
    quiz = models.ForeignKey(Quiz, on_delete=models.CASCADE, related_name='quiz_histories')
    score = models.FloatField(default=0)
    total_questions = models.PositiveIntegerField(default=0)
    correct_answers = models.PositiveIntegerField(default=0)
    started_at = models.DateTimeField(auto_now_add=True)
    completed_at = models.DateTimeField(null=True, blank=True)
    selected_difficulty = models.CharField(max_length=1, choices=Quiz.DIFFICULTY_CHOICES, default='M')

    class Meta:
        indexes = [
            models.Index(fields=['user', '-created_at']),
            models.Index(fields=['quiz', '-score']),
        ]

    @property
    def duration(self):
        """Calculate quiz duration in minutes"""
        if self.completed_at and self.started_at:
            duration = self.completed_at - self.started_at
            return duration.total_seconds() / 60
        return None

    @property
    def percentage_score(self):
        """Calculate percentage score"""
        if self.total_questions > 0:
            return (self.correct_answers / self.total_questions) * 100
        return 0

    def __str__(self):
        return f"{self.user.username} - {self.quiz.title} - {self.score}"

class UserAnswer(BaseModel):
    ANSWER_CHOICES = [
        ("A", "Option A"),
        ("B", "Option B"),
        ("C", "Option C"),
        ("D", "Option D"),
    ]

    history = models.ForeignKey(QuizHistory, related_name='user_answers', on_delete=models.CASCADE)
    question = models.ForeignKey(Question, on_delete=models.CASCADE)
    selected_option = models.CharField(choices=ANSWER_CHOICES, max_length=1)
    is_correct = models.BooleanField(default=False)
    time_taken = models.FloatField(default=0, help_text="Time taken to answer in seconds")

    def __str__(self):
        return f"{self.history.user.username} - {self.question.text[:50]}"

class AIGenerationLog(BaseModel):
    """Track AI-generated content for analytics"""
    category = models.ForeignKey(Category, on_delete=models.CASCADE, null=True, blank=True)
    subcategory = models.ForeignKey(SubCategory, on_delete=models.CASCADE, null=True, blank=True)
    difficulty = models.CharField(max_length=1, choices=Quiz.DIFFICULTY_CHOICES, default='M')
    questions_generated = models.PositiveIntegerField(default=0)
    # Use string reference to avoid circular dependency
    generated_by = models.ForeignKey(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, null=True, blank=True)
    prompt_used = models.TextField(help_text="The prompt used for AI generation")

    def __str__(self):
        return f"AI Generation - {self.category} - {self.difficulty}"

# ---------------- Signals for Profile Creation ----------------

@receiver(post_save, sender=CustomUser)
def create_user_profile(sender, instance, created, **kwargs):
    if created:
        Profile.objects.create(user=instance)

@receiver(post_save, sender=CustomUser)
def save_user_profile(sender, instance, **kwargs):
    if hasattr(instance, 'profile'):
        instance.profile.save()